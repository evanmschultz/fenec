{
    "docstring": "",
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "sys",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": ""
        },
        {
            "import_names": [
                {
                    "name": "Sequence",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": ""
        },
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": ""
        },
        {
            "import_names": [
                {
                    "name": "ImportNameModel",
                    "as_name": "",
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ImportNameModel"
                },
                {
                    "name": "ImportModel",
                    "as_name": "",
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ImportModel"
                },
                {
                    "name": "ImportModuleType",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "fenec.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "fenec.python_parser.visitors.node_processing.common_functions",
                    "as_name": "common_functions",
                    "local_block_id": ""
                }
            ],
            "imported_from": "",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:visitors:node_processing:common_functions.py__*__MODULE"
        }
    ],
    "id": "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE",
    "file_path": "fenec/python_parser/visitors/node_processing/module_functions.py",
    "parent_id": "fenec:python_parser:visitors:node_processing__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 218,
    "code_content": "import sys\nfrom typing import Sequence\n\nimport libcst\n\nfrom fenec.models.models import ImportModel, ImportNameModel, ImportModuleType\nimport fenec.python_parser.visitors.node_processing.common_functions as common_functions\n\n\ndef extract_content_from_empty_lines(\n    sequence: Sequence[libcst.EmptyLine],\n) -> list[str]:\n    \"\"\"\n    Extracts comments from a sequence of EmptyLine nodes.\n\n    Args:\n        - sequence (Sequence[libcst.EmptyLine]): A sequence of libcst.EmptyLine nodes to process.\n\n    Returns:\n        - list[str]: A list of string comments extracted from the EmptyLine nodes.\n\n    Example:\n        ```Python\n        extract_content_from_empty_lines([libcst.EmptyLine(comment=libcst.Comment(\"# Comment\"))])\n        # Returns: ['# Comment']\n        ```\n    \"\"\"\n\n    return [line.comment.value for line in sequence if line.comment]\n\n\ndef process_import(node: libcst.Import) -> ImportModel:\n    \"\"\"\n    Processes an Import node to create an ImportModel.\n\n    Args:\n        - node (libcst.Import): The Import node to process.\n\n    Returns:\n        - ImportModel: An ImportModel representing the processed import.\n\n    Example:\n        ```Python\n        import_model = process_import(libcst.Import(names=[libcst.ImportAlias(name=libcst.Name(\"module\"))]))\n        ```\n    \"\"\"\n\n    import_name_model: ImportNameModel = _build_import_name_model(node)\n    import_model: ImportModel = _build_import_model(\n        import_name_models=[import_name_model]\n    )\n    return import_model\n\n\ndef process_import_from(node: libcst.ImportFrom) -> ImportModel:\n    \"\"\"\n    Processes an ImportFrom node to create an ImportModel.\n\n    Args:\n        - node (libcst.ImportFrom): The ImportFrom node to process.\n\n    Returns:\n        - ImportModel: An ImportModel representing the processed import from statement.\n\n    Example:\n        ```Python\n        import_model = process_import_from(libcst.ImportFrom(module=libcst.Name(\"module\"), names=[libcst.ImportAlias(name=libcst.Name(\"submodule\"))]))\n        ```\n    \"\"\"\n\n    module_name: str | None = (\n        _get_full_module_path(node.module) if node.module else None\n    )\n    import_names: list[ImportNameModel] = _build_import_from_name_models(node)\n    import_module_type: ImportModuleType = _get_import_from_module_type(module_name)\n\n    import_model = ImportModel(\n        import_names=import_names,\n        imported_from=module_name,\n        import_module_type=import_module_type,\n    )\n    return import_model\n\n\ndef _get_import_name(node: libcst.Import) -> str:\n    \"\"\"Gets the import name from an Import node.\"\"\"\n\n    return common_functions.extract_code_content(node.names[0].name)\n\n\ndef _get_as_name(node: libcst.Import) -> str | None:\n    \"\"\"Gets the as name from an Import node.\"\"\"\n\n    first_name: libcst.ImportAlias = node.names[0]\n\n    if first_name.asname and isinstance(first_name.asname, libcst.AsName):\n        as_name_node = first_name.asname.name\n        if isinstance(as_name_node, libcst.Name):\n            return as_name_node.value\n\n\ndef _build_import_name_model(node: libcst.Import) -> ImportNameModel:\n    \"\"\"Builds an ImportNameModel from an Import node.\"\"\"\n\n    import_name: str | None = _get_import_name(node)\n    as_name: str | None = _get_as_name(node)\n    return ImportNameModel(name=import_name, as_name=as_name)\n\n\ndef _is_standard_library_import(import_name: str) -> bool:\n    \"\"\"Checks if an import is a standard library import.\"\"\"\n\n    return import_name in sys.stdlib_module_names\n\n\ndef _third_party_imports() -> list[str]:\n    \"\"\"Gets a list of all third party imports.\"\"\"\n\n    third_party_imports: list[str] = []\n\n    for module_name, module in sys.modules.items():\n        if module_name in sys.stdlib_module_names or not hasattr(module, \"__file__\"):\n            continue\n\n        module_file: str | None = module.__file__\n        if module_file and (\n            \"site-packages\" in module_file or \"dist-packages\" in module_file\n        ):\n            third_party_imports.append(module_name)\n\n    return third_party_imports\n\n\ndef _is_third_party_import(import_name: str) -> bool:\n    \"\"\"Checks if an import is a third party import.\"\"\"\n\n    return import_name in _third_party_imports()\n\n\ndef _determine_import_module_type(module_name: str) -> ImportModuleType:\n    \"\"\"Determines the type of import a module is.\"\"\"\n\n    if _is_standard_library_import(module_name):\n        return ImportModuleType.STANDARD_LIBRARY\n    elif _is_third_party_import(module_name):\n        return ImportModuleType.THIRD_PARTY\n    else:\n        return ImportModuleType.LOCAL\n\n\ndef _get_import_module_type(\n    import_name_models: list[ImportNameModel],\n) -> ImportModuleType:\n    \"\"\"Gets the import module type of a list of ImportNameModels.\"\"\"\n\n    for import_name_model in import_name_models:\n        module_type = _determine_import_module_type(import_name_model.name)\n        if module_type != ImportModuleType.LOCAL:\n            return module_type\n    return ImportModuleType.LOCAL\n\n\ndef _get_import_from_module_type(module_name: str | None) -> ImportModuleType:\n    \"\"\"Gets the import module type of an ImportFrom node.\"\"\"\n\n    if module_name:\n        return _determine_import_module_type(module_name)\n    return ImportModuleType.LOCAL\n\n\ndef _build_import_model(\n    import_name_models: list[ImportNameModel],\n) -> ImportModel:\n    \"\"\"Builds an ImportModel from a list of ImportNameModels.\"\"\"\n\n    import_module_type: ImportModuleType = _get_import_module_type(import_name_models)\n    return ImportModel(\n        import_names=import_name_models,\n        imported_from=None,\n        import_module_type=import_module_type,\n    )\n\n\ndef _get_full_module_path(node) -> str:\n    \"\"\"Recursively gets the full module path from a node and returns it as a string.\"\"\"\n\n    if isinstance(node, libcst.Name):\n        return node.value\n    elif isinstance(node, libcst.Attribute):\n        return common_functions.extract_code_content(node)\n    else:\n        print(f\"\\n\\nImport Node type: {type(node)}\\n\")\n        # return str(node)\n        return common_functions.extract_code_content(node)\n\n\ndef _extract_as_name(import_alias: libcst.ImportAlias) -> str | None:\n    \"\"\"Extracts the as name from an ImportAlias node.\"\"\"\n\n    if import_alias.asname and isinstance(import_alias.asname, libcst.AsName):\n        if isinstance(import_alias.asname.name, libcst.Name):\n            return import_alias.asname.name.value\n\n\ndef _build_import_from_name_models(node: libcst.ImportFrom) -> list[ImportNameModel]:\n    \"\"\"Builds a list of ImportNameModels from an ImportFrom node.\"\"\"\n\n    import_names: list[ImportNameModel] = []\n    if isinstance(node.names, libcst.ImportStar):\n        import_names.append(ImportNameModel(name=\"*\", as_name=None))\n    else:\n        for import_alias in node.names:\n            if isinstance(import_alias, libcst.ImportAlias):\n                name = str(import_alias.name.value)\n                as_name = _extract_as_name(import_alias)\n                import_names.append(ImportNameModel(name=name, as_name=as_name))\n    return import_names\n",
    "important_comments": [],
    "dependencies": [],
    "summary": "This Python code is designed to process and analyze import statements within a Python abstract syntax tree (AST) using the `libcst` library, with the primary goal of extracting and modeling import statements to distinguish between standard library, third-party, and local imports. This functionality is significant for code analysis, refactoring tasks, and dependency management. Key components include: `extract_content_from_empty_lines`, which extracts comments from `libcst.EmptyLine` nodes; `process_import` and `process_import_from`, which convert `libcst.Import` and `libcst.ImportFrom` nodes into `ImportModel` objects; helper functions such as `_get_import_name`, `_get_as_name`, and `_build_import_name_model` for constructing `ImportNameModel` instances; and utility functions like `_is_standard_library_import`, `_is_third_party_import`, and `_determine_import_module_type` for categorizing imports.\n\nThe implementation involves parsing import nodes and determining the type of each import using a series of helper functions. The code employs a structured approach to handle different import scenarios, leveraging data structures like lists and custom models (`ImportModel`, `ImportNameModel`) to encapsulate import details. The process includes extracting import names and aliases, determining the module type (standard library, third-party, or local), and building comprehensive models with functions like `_build_import_model` and `_build_import_from_name_models`. Notable algorithms include recursive parsing for full module paths and filtering logic for third-party modules based on their file paths.\n\nThe technical stack includes `libcst` for parsing and manipulating Python code, which provides a concrete syntax tree that retains formatting details, and the `fenec` library for modeling imports, which likely offers predefined models and utilities for handling import data. The code also utilizes Python's `sys` module to access standard library module names and currently loaded modules for third-party detection.\n\nIn the context of a larger system, this code serves as a foundational utility for analyzing Python codebases, potentially interacting with other components that require detailed import information for tasks such as dependency analysis, code transformation, or static analysis. It could be integrated into a broader code analysis toolchain, providing essential data for understanding code dependencies and facilitating automated refactoring or compliance checks. Its modular design allows it to be extended or adapted for various use cases within software development and maintenance workflows.",
    "children_ids": [
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-extract_content_from_empty_lines",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-process_import",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-process_import_from",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_get_import_name",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_get_as_name",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_build_import_name_model",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_is_standard_library_import",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_third_party_imports",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_is_third_party_import",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_determine_import_module_type",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_get_import_module_type",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_get_import_from_module_type",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_build_import_model",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_get_full_module_path",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_extract_as_name",
        "fenec:python_parser:visitors:node_processing:module_functions.py__*__MODULE__*__FUNCTION-_build_import_from_name_models"
    ]
}