{
    "docstring": "",
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "json",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": ""
        },
        {
            "import_names": [
                {
                    "name": "BaseModel",
                    "as_name": "",
                    "local_block_id": ""
                },
                {
                    "name": "Field",
                    "as_name": "",
                    "local_block_id": ""
                },
                {
                    "name": "field_validator",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "pydantic",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": ""
        },
        {
            "import_names": [
                {
                    "name": "ImportModuleType",
                    "as_name": "",
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-ImportModuleType"
                },
                {
                    "name": "CommentType",
                    "as_name": "",
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-CommentType"
                },
                {
                    "name": "BlockType",
                    "as_name": "",
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-BlockType"
                }
            ],
            "imported_from": "fenec.models.enums",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:enums.py__*__MODULE"
        }
    ],
    "id": "fenec:models:models.py__*__MODULE",
    "file_path": "fenec/models/models.py",
    "parent_id": "fenec:models__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 1021,
    "code_content": "import json\nfrom pydantic import BaseModel, Field, field_validator\n\nfrom fenec.models.enums import (\n    BlockType,\n    ImportModuleType,\n    CommentType,\n)\n\n\nclass ImportNameModel(BaseModel):\n    \"\"\"Class representing the name of an import.\"\"\"\n\n    name: str\n    as_name: str | None = None\n    local_block_id: str | None = None\n\n    @field_validator(\"as_name\")\n    def _check_as_name(cls, v) -> str:\n        \"\"\"Validates the as_name field.\"\"\"\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"local_block_id\")\n    def _check_local_block_id(cls, v) -> str:\n        \"\"\"Validates the local_block_id field.\"\"\"\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n\nclass ImportModel(BaseModel):\n    \"\"\"Class representing an import statement.\"\"\"\n\n    import_names: list[ImportNameModel]\n    imported_from: str | None = None\n    import_module_type: ImportModuleType = ImportModuleType.STANDARD_LIBRARY\n    local_module_id: str | None = None\n\n    @field_validator(\"imported_from\")\n    def _check_imported_from(cls, v) -> str:\n        \"\"\"Validates the imported_from field.\"\"\"\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"local_module_id\")\n    def _check_local_module_id(cls, v) -> str:\n        \"\"\"Validates the local_module_id field.\"\"\"\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    def _convert_import_to_metadata(self) -> str:\n        \"\"\"Converts the import to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n\nclass DependencyModel(BaseModel):\n    \"\"\"Class representing a module dependency.\"\"\"\n\n    code_block_id: str\n\n    def _convert_dependency_to_metadata(self) -> str:\n        \"\"\"Converts the dependency to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n\nclass CommentModel(BaseModel):\n    \"\"\"Class representing a comment.\"\"\"\n\n    content: str\n    comment_types: list[CommentType]\n\n    def _convert_comment_to_metadata(self) -> str:\n        \"\"\"Converts the comment to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n\nclass DecoratorModel(BaseModel):\n    \"\"\"Class representing a decorator.\"\"\"\n\n    content: str\n    decorator_name: str\n    decorator_args: list[str] | None = None\n\n    @field_validator(\"decorator_args\")\n    def _check_decorator_args(cls, v) -> list[str]:\n        \"\"\"Validates the decorator_args field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    def _convert_decorator_to_metadata(self) -> str:\n        \"\"\"Converts the decorator to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n\nclass ClassKeywordModel(BaseModel):\n    \"\"\"Class representing a class keyword.\"\"\"\n\n    content: str\n    keyword_name: str\n    args: str | None = None\n\n    @field_validator(\"args\")\n    def _check_args(cls, v) -> str:\n        \"\"\"Validates the args field.\"\"\"\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    def _convert_class_keyword_to_metadata(self) -> str:\n        \"\"\"Converts the class keyword to a metadata string.\"\"\"\n        return self.model_dump_json()\n\n\nclass ParameterListModel(BaseModel):\n    \"\"\"Class representing a list of parameters.\"\"\"\n\n    params: list[str] | None = None\n    star_arg: str | None = None\n    kwonly_params: list[str] | None = None\n    star_kwarg: str | None = None\n    posonly_params: list[str] | None = None\n\n    @field_validator(\"params\")\n    def _check_params(cls, v) -> list[str]:\n        \"\"\"Validates the params field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"star_arg\")\n    def _check_star_arg(cls, v) -> str:\n        \"\"\"Validates the star_arg field.\"\"\"\n        if v is None:\n            # return ParameterModel(content=\"\")\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"kwonly_params\")\n    def _check_kwonly_params(cls, v) -> list[str]:\n        \"\"\"Validates the kwonly_params field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"star_kwarg\")\n    def _check_star_kwarg(cls, v) -> str:\n        \"\"\"Validates the star_kwarg field.\"\"\"\n        if v is None:\n            # return ParameterModel(content=\"\")\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"posonly_params\")\n    def _check_posonly_params(cls, v) -> list[str]:\n        \"\"\"Validates the posonly_params field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    def _convert_parameters_to_metadata(self) -> str:\n        \"\"\"Converts the parameter list to a metadata string.\"\"\"\n\n        params: str = json.dumps(self.params, indent=4)\n        kwonly_params: str = json.dumps(self.kwonly_params, indent=4)\n        posonly_params: str = json.dumps(self.posonly_params, indent=4)\n        return json.dumps(\n            {\n                \"params\": params,\n                \"star_arg\": self.star_arg,\n                \"kwonly_params\": kwonly_params,\n                \"star_kwarg\": self.star_kwarg,\n                \"posonly_params\": posonly_params,\n            }\n        )\n\n    @classmethod\n    def _build_parameter_list_model_from_metadata(\n        cls, metadata: str\n    ) -> \"ParameterListModel\":\n        \"\"\"Builds a parameter list model from metadata.\"\"\"\n\n        meta_data: dict = json.loads(metadata)\n        params: list[str] = json.loads(meta_data[\"params\"])\n        star_arg: str = meta_data[\"star_arg\"]\n        kwonly_params: list[str] = json.loads(meta_data[\"kwonly_params\"])\n        star_kwarg: str = meta_data[\"star_kwarg\"]\n        posonly_params: list[str] = json.loads(meta_data[\"posonly_params\"])\n\n        return cls(\n            params=params,\n            star_arg=star_arg,\n            kwonly_params=kwonly_params,\n            star_kwarg=star_kwarg,\n            posonly_params=posonly_params,\n        )\n\n\nclass BaseCodeBlockModel(BaseModel):\n    \"\"\"Attributes common to all code block models.\"\"\"\n\n    id: str\n    file_path: str = Field(min_length=1)\n    parent_id: str | None = None\n    block_type: BlockType\n    start_line_num: int\n    end_line_num: int\n    code_content: str = \"\"\n    important_comments: list[CommentModel] | None = None\n    dependencies: list[ImportModel | DependencyModel] | None = None\n    summary: str | None = None\n    children_ids: list[str] | None = []\n\n    @field_validator(\"parent_id\")\n    def _check_parent_id(cls, v, values) -> str:\n        \"\"\"Validates that parent_id is a non-empty string unless block_type is MODULE.\"\"\"\n        block_type = (\n            values.get(\"block_type\")\n            if isinstance(values, dict)\n            else values.data.get(\"block_type\")\n        )\n\n        if block_type and block_type != BlockType.MODULE:\n            if v is None or len(v) < 1:\n                raise ValueError(\n                    \"parent_id must be a non-empty string unless block_type is MODULE\"\n                )\n        return v\n\n    @field_validator(\"important_comments\")\n    def _check_important_comments(cls, v) -> list[CommentModel] | None:\n        \"\"\"Validates the important_comments field.\"\"\"\n\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"dependencies\")\n    def _check_dependencies(cls, v) -> list[ImportModel | DependencyModel] | None:\n        \"\"\"Validates the dependencies field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"summary\")\n    def _check_summary(cls, v) -> str:\n        \"\"\"Validates the summary field.\"\"\"\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"children_ids\")\n    def _check_children_ids(cls, v) -> list[str]:\n        \"\"\"Validates the children_ids field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    def _convert_base_attributes_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the base attributes to a metadata dictionary.\"\"\"\n\n        children_ids: str = json.dumps(self.children_ids, indent=4)\n        dependencies: str = json.dumps(\n            [\n                (\n                    dependency._convert_dependency_to_metadata()\n                    if isinstance(dependency, DependencyModel)\n                    else dependency._convert_import_to_metadata()\n                )\n                for dependency in self.dependencies  # type: ignore\n            ],\n            indent=4,\n        )\n        important_comments: str = json.dumps(\n            [\n                comment._convert_comment_to_metadata()\n                for comment in self.important_comments  # type: ignore\n            ],\n            indent=4,\n        )\n        return {\n            \"id\": self.id,\n            \"file_path\": self.file_path,\n            \"parent_id\": self.parent_id,  # type: ignore\n            \"block_type\": self.block_type.name,\n            \"start_line_num\": self.start_line_num,\n            \"end_line_num\": self.end_line_num,\n            \"code_content\": self.code_content,\n            \"important_comments\": important_comments,\n            \"dependencies\": dependencies,\n            \"summary\": self.summary,\n            \"children_ids\": children_ids,\n        }\n\n    @classmethod\n    def _build_base_code_block_model_from_metadata(\n        cls, metadata: dict\n    ) -> \"BaseCodeBlockModel\":\n        \"\"\"Builds a base code block model from metadata.\"\"\"\n\n        important_comments: list[CommentModel] | None = []\n        for comment in json.loads(metadata[\"important_comments\"]):\n            important_comments.append(CommentModel(**comment))\n        if important_comments is []:\n            important_comments = None\n\n        dependencies: list[ImportModel | DependencyModel] | None = []\n        for dependency_str in json.loads(metadata[\"dependencies\"]):\n            dependency = json.loads(dependency_str)\n            if \"import_names\" in dependency:\n                dependencies.append(ImportModel(**dependency))\n            else:\n                dependencies.append(DependencyModel(**dependency))\n        if dependencies is []:\n            dependencies = None\n\n        children_ids: list[str] | None = json.loads(metadata[\"children_ids\"])\n        if children_ids is []:\n            children_ids = None\n\n        instance_dict = {\n            \"id\": metadata[\"id\"],\n            \"file_path\": metadata[\"file_path\"],\n            \"parent_id\": metadata[\"parent_id\"],\n            \"block_type\": metadata[\"block_type\"],\n            \"start_line_num\": metadata[\"start_line_num\"],\n            \"end_line_num\": metadata[\"end_line_num\"],\n            \"code_content\": metadata[\"code_content\"],\n            \"important_comments\": important_comments,\n            \"dependencies\": dependencies,\n            \"summary\": metadata[\"summary\"],\n            \"children_ids\": children_ids,\n        }\n        return cls(**instance_dict)\n\n\nclass ModuleSpecificAttributes(BaseModel):\n    \"\"\"Module specific attributes.\"\"\"\n\n    docstring: str | None = None\n    header: list[str] | None = None\n    footer: list[str] | None = None\n    imports: list[ImportModel] | None = None\n\n    @field_validator(\"docstring\")\n    def _check_docstring(cls, v) -> str:\n        \"\"\"Validates the docstring field.\"\"\"\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"header\")\n    def _check_header(cls, v) -> list[str]:\n        \"\"\"Validates the header field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"footer\")\n    def _check_footer(cls, v) -> list[str]:\n        \"\"\"Validates the footer field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"imports\")\n    def _check_imports(cls, v) -> list[ImportModel]:\n        \"\"\"Validates the imports field.\"\"\"\n        if v is None:\n            return []\n        else:\n            return v\n\n    def _convert_module_attributes_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the module attributes to a metadata dictionary.\"\"\"\n\n        header: str = json.dumps(self.header, indent=4)\n        footer: str = json.dumps(self.footer, indent=4)\n        imports: str = json.dumps([import_model._convert_import_to_metadata() for import_model in self.imports], indent=4)  # type: ignore\n        return {\n            \"docstring\": self.docstring,  # type: ignore\n            \"header\": header,\n            \"footer\": footer,\n            \"imports\": imports,\n        }\n\n    @classmethod\n    def _build_module_specific_attributes_from_metadata(\n        cls, metadata: dict\n    ) -> \"ModuleSpecificAttributes\":\n        \"\"\"Builds module specific attributes from metadata.\"\"\"\n\n        header: list[str] = json.loads(metadata[\"header\"])\n        footer: list[str] = json.loads(metadata[\"footer\"])\n        imports: list[ImportModel] = []\n        for import_data in json.loads(metadata[\"imports\"]):\n            imports.append(ImportModel(**json.loads(import_data)))\n        instance_dict = {\n            \"docstring\": metadata[\"docstring\"],\n            \"header\": header,\n            \"footer\": footer,\n            \"imports\": imports,\n        }\n        return cls(**instance_dict)\n\n\nclass ModuleModel(BaseCodeBlockModel, ModuleSpecificAttributes):\n    \"\"\"\n    Pydantic model for a module code block.\n\n    Attributes:\n        - `id` (str): The unique identifier for the module.\n        - `file_path` (str): The path to the Python file that the module represents.\n        - `parent_id` (str | None): The identifier of the parent (usually a directory).\n        - `block_type` (BlockType): The type of code block that the module represents.\n        - `start_line_num` (int): The line number of the first line of the module.\n        - `end_line_num` (int): The line number of the last line of the module.\n        - `code_content` (str): The string content of the module.\n        - `important_comments` (list[CommentModel] | None): A list of important comments in the module.\n        - `dependencies` (list[ImportModel | DependencyModel] | None): A list of dependencies for the module.\n        - `summary` (str | None): A summary of the module.\n        - `children_ids` (list[str] | None): A list of the identifiers of the children of the module.\n        - `docstring` (str | None): The docstring of the module.\n        - `header` (list[str] | None): The header of the module.\n        - `footer` (list[str] | None): The footer of the module.\n        - `imports` (list[ImportModel] | None): A list of import statements in the module.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`\n            - Converts the module model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata: dict) -> ModuleModel`\n            - Builds a ModuleModel from a metadata dictionary.\n    \"\"\"\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"\n        Converts the module model to a metadata dictionary for ChromaDB.\n\n        ChromaDB uses an extremely flat, JSON-like schema that only accepts simple types, [str | int | float | bool]. Thus this method\n        flattens the module model's attributes and saves them in a dictionary to be stored in a ChromaDB collection.\n\n        Returns:\n            - `dict[str, str | int]`: A dictionary containing the module model's attributes.\n        \"\"\"\n        return {\n            **self._convert_base_attributes_to_metadata(),\n            **self._convert_module_attributes_to_metadata(),\n        }\n\n    @classmethod\n    def build_from_metadata(cls, metadata: dict) -> \"ModuleModel\":\n        \"\"\"\n        Builds a ModuleModel from a metadata dictionary.\n\n        This method uses the metadata dictionary from a ChromaDB collection to instantiate a ModuleModel object. It builds a\n        `BaseCodeBlockModel` and a `ModuleSpecificAttributes` object from the metadata, combing them into a `ModuleModel` object.\n\n        Args:\n            - `metadata` (dict): A dictionary containing the metadata for the ModuleModel.\n\n        Returns:\n            - `ModuleModel`: A ModuleModel object with the attributes from the metadata dictionary.\n        \"\"\"\n\n        base_code_block_model: BaseCodeBlockModel = (\n            BaseCodeBlockModel._build_base_code_block_model_from_metadata(metadata)\n        )\n        module_specific_attributes: ModuleSpecificAttributes = (\n            ModuleSpecificAttributes._build_module_specific_attributes_from_metadata(\n                metadata\n            )\n        )\n        return cls(\n            **module_specific_attributes.model_dump(),\n            **base_code_block_model.model_dump(),\n        )\n\n\nclass ClassSpecificAttributes(BaseModel):\n    \"\"\"Class specific attributes.\"\"\"\n\n    class_name: str = Field(min_length=1)\n    decorators: list[DecoratorModel] | None = None\n    bases: list[str] | None = None\n    docstring: str | None = None\n    keywords: list[ClassKeywordModel] | None = None\n\n    @field_validator(\"decorators\")\n    def _check_decorators(cls, v) -> list[DecoratorModel]:\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"bases\")\n    def _check_bases(cls, v) -> list[str]:\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"docstring\")\n    def _check_docstring(cls, v) -> str:\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"keywords\")\n    def _check_keywords(cls, v) -> list[ClassKeywordModel]:\n        if v is None:\n            return []\n        else:\n            return v\n\n    def _convert_class_attributes_to_metadata(self) -> dict[str, str]:\n        decorators: str = json.dumps(\n            [\n                decorator._convert_decorator_to_metadata()\n                for decorator in self.decorators  # type: ignore\n            ],\n            indent=4,\n        )\n        keywords: str = json.dumps(\n            [\n                keyword._convert_class_keyword_to_metadata()\n                for keyword in self.keywords  # type: ignore\n            ],\n            indent=4,\n        )\n        bases: str = json.dumps(self.bases, indent=4)\n        return {\n            \"class_name\": self.class_name,\n            \"decorators\": decorators,\n            \"bases\": bases,\n            \"docstring\": self.docstring if self.docstring else \"\",\n            \"keywords\": keywords,\n        }\n\n    @classmethod\n    def _build_class_specific_attributes_from_metadata(\n        cls, metadata: dict\n    ) -> \"ClassSpecificAttributes\":\n        \"\"\"Builds class specific attributes from metadata.\"\"\"\n\n        decorators: list[DecoratorModel] | None = []\n        for decorator_data in json.loads(metadata[\"decorators\"]):\n            decorators.append(DecoratorModel(**json.loads(decorator_data)))\n        if decorators is []:\n            decorators = None\n\n        keywords: list[ClassKeywordModel] | None = []\n        for keyword_data in json.loads(metadata[\"keywords\"]):\n            keywords.append(ClassKeywordModel(**json.loads(keyword_data)))\n        if keywords is []:\n            keywords = None\n\n        bases: list[str] = json.loads(metadata[\"bases\"])\n        docstring: str | None = metadata[\"docstring\"] if metadata[\"docstring\"] else None\n\n        return cls(\n            class_name=metadata[\"class_name\"],\n            decorators=decorators,\n            bases=bases,\n            docstring=docstring,\n            keywords=keywords,\n        )\n\n\nclass ClassModel(BaseCodeBlockModel, ClassSpecificAttributes):\n    \"\"\"\n    Pydantic model for a class code block.\n\n    Attributes:\n        - `id` (str): The unique identifier for the class.\n        - `file_path` (str): The path to the Python file that the class represents.\n        - `parent_id` (str | None): The identifier of the parent (usually a module).\n        - `block_type` (BlockType): The type of code block that the class represents.\n        - `start_line_num` (int): The line number of the first line of the class.\n        - `end_line_num` (int): The line number of the last line of the class.\n        - `code_content` (str): The string content of the class.\n        - `important_comments` (list[CommentModel] | None): A list of important comments in the class.\n        - `dependencies` (list[ImportModel | DependencyModel] | None): A list of dependencies for the class.\n        - `summary` (str | None): A summary of the class.\n        - `children_ids` (list[str] | None): A list of the identifiers of the children of the class.\n        - `class_name` (str): The name of the class.\n        - `decorators` (list[DecoratorModel] | None): A list of decorators for the class.\n        - `bases` (list[str] | None): A list of base classes for the class.\n        - `docstring` (str | None): The docstring of the class.\n        - `keywords` (list[ClassKeywordModel] | None): A list of keywords for the class.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`\n            - Converts the class model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata: dict) -> ClassModel`\n            - Builds a ClassModel from a metadata dictionary.\n    \"\"\"\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"\n        Converts the class model to a metadata dictionary for ChromaDB.\n\n        ChromaDB uses an extremely flat, JSON-like schema that only accepts simple types, [str | int | float | bool]. Thus this method\n        flattens the class model's attributes and saves them in a dictionary to be stored in a ChromaDB collection.\n\n        Returns:\n            - `dict[str, str | int]`: A dictionary containing the class model's attributes.\n        \"\"\"\n\n        return {\n            **self._convert_base_attributes_to_metadata(),\n            **self._convert_class_attributes_to_metadata(),\n        }\n\n    @classmethod\n    def build_from_metadata(cls, metadata: dict) -> \"ClassModel\":\n        \"\"\"\n        Builds a ClassModel from a metadata dictionary.\n\n        This method uses the metadata dictionary from a ChromaDB collection to instantiate a ClassModel object. It builds a\n        `BaseCodeBlockModel` and a `ClassSpecificAttributes` object from the metadata, combing them into a `ClassModel` object.\n\n        Args:\n            - `metadata` (dict): A dictionary containing the metadata for the ClassModel.\n\n        Returns:\n            - `ClassModel`: A ClassModel object with the attributes from the metadata dictionary.\n        \"\"\"\n\n        class_specific_attributes: ClassSpecificAttributes = (\n            ClassSpecificAttributes._build_class_specific_attributes_from_metadata(\n                metadata\n            )\n        )\n        base_code_block_model: BaseCodeBlockModel = (\n            BaseCodeBlockModel._build_base_code_block_model_from_metadata(metadata)\n        )\n        return cls(\n            **class_specific_attributes.model_dump(),\n            **base_code_block_model.model_dump(),\n        )\n\n\nclass FunctionSpecificAttributes(BaseModel):\n    \"\"\"Function specific attributes.\"\"\"\n\n    function_name: str = Field(min_length=1)\n    docstring: str | None = None\n    decorators: list[DecoratorModel] | None = None\n    parameters: ParameterListModel | None = None\n    returns: str | None = None\n    is_method: bool = False\n    is_async: bool = False\n\n    @field_validator(\"docstring\")\n    def _check_docstring(cls, v) -> str:\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"decorators\")\n    def _check_decorators(cls, v) -> list[DecoratorModel]:\n        if v is None:\n            return []\n        else:\n            return v\n\n    @field_validator(\"parameters\")\n    def _check_parameters(cls, v) -> ParameterListModel:\n        if v is None:\n            return ParameterListModel(\n                params=None,\n                star_arg=None,\n                kwonly_params=None,\n                star_kwarg=None,\n                posonly_params=None,\n            )\n        else:\n            return v\n\n    @field_validator(\"returns\")\n    def _check_returns(cls, v) -> str:\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    def _convert_function_attributes_to_metadata(self) -> dict[str, str | int | bool]:\n        \"\"\"Converts the function attributes to a metadata dictionary for ChromaDB.\"\"\"\n\n        decorators: str = json.dumps(\n            (\n                [\n                    decorator._convert_decorator_to_metadata()\n                    for decorator in self.decorators  # type: ignore\n                ]\n            ),\n            indent=4,\n        )\n        parameters: str = (\n            self.parameters._convert_parameters_to_metadata() if self.parameters else \"\"\n        )\n\n        return {\n            \"function_name\": self.function_name,\n            \"docstring\": self.docstring if self.docstring else \"\",\n            \"decorators\": decorators,\n            \"parameters\": parameters,\n            \"returns\": self.returns if self.returns else \"\",\n            \"is_method\": self.is_method,\n            \"is_async\": self.is_async,\n        }\n\n    @classmethod\n    def _build_function_specific_attributes_from_metadata(\n        cls, metadata: dict\n    ) -> \"FunctionSpecificAttributes\":\n        \"\"\"Builds function specific attributes from metadata.\"\"\"\n\n        decorators: list[DecoratorModel] | None = []\n        if metadata[\"decorators\"]:\n            for decorator_data in json.loads(metadata[\"decorators\"]):\n                decorators.append(DecoratorModel(**json.loads(decorator_data)))\n            if decorators is []:\n                decorators = None\n\n        parameters: ParameterListModel | None = (\n            ParameterListModel._build_parameter_list_model_from_metadata(\n                metadata[\"parameters\"]\n            )\n        )\n        if parameters is None:\n            parameters = None\n\n        returns: str = metadata[\"returns\"]\n\n        return cls(\n            function_name=metadata[\"function_name\"],\n            docstring=metadata[\"docstring\"],\n            decorators=decorators,\n            parameters=parameters,\n            returns=returns,\n            is_method=metadata[\"is_method\"],\n            is_async=metadata[\"is_async\"],\n        )\n\n\nclass FunctionModel(BaseCodeBlockModel, FunctionSpecificAttributes):\n    \"\"\"\n    Pydantic model for a function code block.\n\n    Attributes:\n        - `id` (str): The unique identifier for the function.\n        - `file_path` (str): The path to the Python file that the function represents.\n        - `parent_id` (str | None): The identifier of the parent (usually a module or class).\n        - `block_type` (BlockType): The type of code block that the function represents.\n        - `start_line_num` (int): The line number of the first line of the function.\n        - `end_line_num` (int): The line number of the last line of the function.\n        - `code_content` (str): The string content of the function.\n        - `important_comments` (list[CommentModel] | None): A list of important comments in the function.\n        - `dependencies` (list[ImportModel | DependencyModel] | None): A list of dependencies for the function.\n        - `summary` (str | None): A summary of the function.\n        - `children_ids` (list[str] | None): A list of the identifiers of the children of the function.\n        - `function_name` (str): The name of the function.\n        - `docstring` (str | None): The docstring of the function.\n        - `decorators` (list[DecoratorModel] | None): A list of decorators for the function.\n        - `parameters` (ParameterListModel | None): A model representing the function's parameters.\n        - `returns` (str | None): A string representing the function's return annotation.\n        - `is_method` (bool): True if the function is a method, False otherwise.\n        - `is_async` (bool): True if the function is asynchronous, False otherwise.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`\n            - Converts the function model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata: dict) -> FunctionModel`\n            - Builds a FunctionModel from a metadata dictionary.\n    \"\"\"\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"\n        Converts the function model to a metadata dictionary for ChromaDB.\n\n        ChromaDB uses an extremely flat, JSON-like schema that only accepts simple types, [str | int | float | bool]. Thus this method\n        flattens the function model's attributes and saves them in a dictionary to be stored in a ChromaDB collection.\n\n        Returns:\n            - `dict[str, str | int]`: A dictionary containing the function model's attributes.\n        \"\"\"\n\n        return {\n            **self._convert_base_attributes_to_metadata(),\n            **self._convert_function_attributes_to_metadata(),\n        }\n\n    @classmethod\n    def build_from_metadata(cls, metadata: dict) -> \"FunctionModel\":\n        \"\"\"\n        Builds a FunctionModel from a metadata dictionary.\n\n        This method uses the metadata dictionary from a ChromaDB collection to instantiate a FunctionModel object. It builds a\n        `BaseCodeBlockModel` and a `FunctionSpecificAttributes` object from the metadata, combing them into a `FunctionModel` object.\n\n        Args:\n            - `metadata` (dict): A dictionary containing the metadata for the FunctionModel.\n\n        Returns:\n            - `FunctionModel`: A FunctionModel object with the attributes from the metadata dictionary.\n        \"\"\"\n\n        function_specific_attributes: FunctionSpecificAttributes = (\n            FunctionSpecificAttributes._build_function_specific_attributes_from_metadata(\n                metadata\n            )\n        )\n        base_code_block_model: BaseCodeBlockModel = (\n            BaseCodeBlockModel._build_base_code_block_model_from_metadata(metadata)\n        )\n        return cls(\n            **function_specific_attributes.model_dump(),\n            **base_code_block_model.model_dump(),\n        )\n\n\nclass StandaloneCodeBlockSpecificAttributes(BaseModel):\n    \"\"\"Standalone code block specific attributes.\"\"\"\n\n    variable_assignments: list[str] | None = None\n\n    @field_validator(\"variable_assignments\")\n    def _check_variable_assignments(cls, v) -> list[str]:\n        if v is None:\n            return []\n        else:\n            return v\n\n    def _convert_standalone_block_attributes_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the standalone block attributes to a metadata dictionary.\"\"\"\n        return {\n            \"variable_assignments\": json.dumps(self.variable_assignments, indent=4),\n        }\n\n    @classmethod\n    def _build_standalone_block_specific_attributes_from_metadata(\n        cls, metadata: dict\n    ) -> \"StandaloneCodeBlockSpecificAttributes\":\n        \"\"\"Builds standalone block specific attributes from metadata.\"\"\"\n        variable_assignments: list[str] = json.loads(metadata[\"variable_assignments\"])\n        return cls(variable_assignments=variable_assignments)\n\n\nclass StandaloneCodeBlockModel(\n    BaseCodeBlockModel, StandaloneCodeBlockSpecificAttributes\n):\n    \"\"\"\n    Model for a standalone code block.\n\n    Attributes:\n        - `id` (str): The unique identifier for the standalone code block.\n        - `file_path` (str): The path to the Python file that the standalone code block represents.\n        - `parent_id` (str | None): The identifier of the parent (usually a module or class).\n        - `block_type` (BlockType): The type of code block that the standalone code block represents.\n        - `start_line_num` (int): The line number of the first line of the standalone code block.\n        - `end_line_num` (int): The line number of the last line of the standalone code block.\n        - `code_content` (str): The string content of the standalone code block.\n        - `important_comments` (list[CommentModel] | None): A list of important comments in the standalone code block.\n        - `dependencies` (list[ImportModel | DependencyModel] | None): A list of dependencies for the standalone code block.\n        - `summary` (str | None): A summary of the standalone code block.\n        - `children_ids` (list[str] | None): A list of the identifiers of the children of the standalone code block.\n        - `variable_assignments` (list[str] | None): A list of variable assignments in the standalone code block.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`\n            - Converts the standalone code block model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata: dict) -> StandaloneCodeBlockModel`\n            - Builds a StandaloneCodeBlockModel from a metadata dictionary.\n    \"\"\"\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"\n        Converts the standalone code block model to a metadata dictionary for ChromaDB.\n\n        ChromaDB uses an extremely flat, JSON-like schema that only accepts simple types, [str | int | float | bool]. Thus this method\n        flattens the standalone code block model's attributes and saves them in a dictionary to be stored in a ChromaDB collection.\n\n        Returns:\n            - `dict[str, str | int]`: A dictionary containing the standalone code block model's attributes.\n        \"\"\"\n\n        return {\n            **self._convert_base_attributes_to_metadata(),\n            **self._convert_standalone_block_attributes_to_metadata(),\n        }\n\n    @classmethod\n    def build_from_metadata(cls, metadata: dict) -> \"StandaloneCodeBlockModel\":\n        \"\"\"\n        Builds a StandaloneCodeBlockModel from a metadata dictionary.\n\n        This method uses the metadata dictionary from a ChromaDB collection to instantiate a StandaloneCodeBlockModel object. It builds a\n        `BaseCodeBlockModel` and a `StandaloneCodeBlockSpecificAttributes` object from the metadata, combing them into a `StandaloneCodeBlockModel` object.\n\n        Args:\n            - `metadata` (dict): A dictionary containing the metadata for the StandaloneCodeBlockModel.\n\n        Returns:\n            - `StandaloneCodeBlockModel`: A StandaloneCodeBlockModel object with the attributes from the metadata dictionary.\n        \"\"\"\n\n        standalone_block_specific_attributes: StandaloneCodeBlockSpecificAttributes = (\n            StandaloneCodeBlockSpecificAttributes._build_standalone_block_specific_attributes_from_metadata(\n                metadata\n            )\n        )\n        base_code_block_model: BaseCodeBlockModel = (\n            BaseCodeBlockModel._build_base_code_block_model_from_metadata(metadata)\n        )\n\n        return cls(\n            **standalone_block_specific_attributes.model_dump(),\n            **base_code_block_model.model_dump(),\n        )\n\n\nclass DirectoryModel(BaseModel):\n    \"\"\"\n    Model for a directory.\n\n    Attributes:\n        - `id` (str): The unique identifier for the directory.\n        - `block_type` (BlockType): The type of code block that the directory represents.\n        - `directory_name` (str): The name of the directory.\n        - `sub_directories_ids` (list[str]): A list of the identifiers of the sub-directories of the directory.\n        - `children_ids` (list[str]): A list of the identifiers of the children of the directory.\n        - `parent_id` (str | None): The identifier of the parent (usually a directory).\n        - `summary` (str | None): A summary of the directory.\n\n    Methods:\n        - `convert_to_metadata() -> dict[str, str | int]`:\n            - Converts the directory model to a metadata dictionary for ChromaDB.\n        - `build_from_metadata(metadata: dict) -> DirectoryModel`:\n            - Builds a DirectoryModel from a metadata dictionary.\n    \"\"\"\n\n    id: str\n    block_type: BlockType = BlockType.DIRECTORY\n    directory_name: str\n    sub_directories_ids: list[str]\n    children_ids: list[str]\n    parent_id: str | None\n    summary: str | None = None\n\n    @field_validator(\"block_type\")\n    def _check_block_type(cls, v) -> str:\n        if v != BlockType.DIRECTORY:\n            raise ValueError(\"Block type must be DIRECTORY\")\n        return v\n\n    @field_validator(\"parent_id\")\n    def _check_parent_id(cls, v) -> str:\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    @field_validator(\"summary\")\n    def _check_summary(cls, v) -> str:\n        if v is None:\n            return \"\"\n        else:\n            return v\n\n    def convert_to_metadata(self) -> dict[str, str | int]:\n        \"\"\"Converts the directory model to a metadata dictionary for ChromaDB.\"\"\"\n\n        sub_directories_ids: str = json.dumps(self.sub_directories_ids, indent=4)\n        children_ids: str = json.dumps(self.children_ids, indent=4)\n        return {\n            \"directory_name\": self.directory_name,\n            \"sub_directories_ids\": sub_directories_ids,\n            \"children_ids\": children_ids,\n            \"parent_id\": self.parent_id,  # type: ignore\n            \"summary\": self.summary,\n        }\n\n    @classmethod\n    def build_from_metadata(cls, metadata: dict) -> \"DirectoryModel\":\n        sub_directories_ids: list[str] = json.loads(metadata[\"sub_directories_ids\"])\n        children_ids: list[str] = json.loads(metadata[\"children_ids\"])\n\n        return cls(\n            id=metadata[\"id\"],\n            directory_name=metadata[\"directory_name\"],\n            sub_directories_ids=sub_directories_ids,\n            children_ids=children_ids,\n            parent_id=metadata[\"parent_id\"],\n            summary=metadata[\"summary\"],\n        )\n",
    "important_comments": [],
    "dependencies": [],
    "summary": "The provided Python code defines a comprehensive set of Pydantic models to represent various components of a codebase, such as imports, dependencies, comments, decorators, classes, functions, standalone code blocks, and directories. The primary purpose of this code is to facilitate the conversion of these components into metadata suitable for storage in a ChromaDB collection, which uses a flat, JSON-like schema. This metadata representation is crucial for enabling efficient storage, retrieval, and analysis of code components in a structured format, supporting advanced features like code search, dependency analysis, and documentation generation.\n\nKey components include: `ImportNameModel` and `ImportModel` for handling import statements, ensuring that import names and their aliases are correctly validated and converted to metadata; `DependencyModel` for module dependencies, capturing the relationships between different code blocks; `CommentModel` for comments, categorizing them using `CommentType` and converting them to metadata; `DecoratorModel` for decorators, validating decorator arguments and converting them to metadata; `ClassKeywordModel` for class keywords, handling keyword arguments and metadata conversion; `ParameterListModel` for function parameters, supporting various parameter types and converting them to metadata; `BaseCodeBlockModel` for common attributes across code blocks, providing a foundation for other models; `ModuleSpecificAttributes` and `ModuleModel` for module-specific data, combining base attributes with module-specific ones; `ClassSpecificAttributes` and `ClassModel` for class-specific data, integrating class-specific attributes with base code block attributes; `FunctionSpecificAttributes` and `FunctionModel` for function-specific data, managing function attributes and metadata conversion; `StandaloneCodeBlockSpecificAttributes` and `StandaloneCodeBlockModel` for standalone code blocks, handling variable assignments and metadata conversion; and `DirectoryModel` for directories, managing directory-specific attributes and metadata conversion.\n\nThe implementation leverages Pydantic's `BaseModel` to define data structures with type validation and uses `field_validator` to ensure fields are correctly populated, defaulting to empty strings or lists where necessary. Each model includes methods to convert its attributes to a metadata dictionary, which is essential for integration with ChromaDB. The models also provide class methods to reconstruct instances from metadata, supporting the round-trip conversion between objects and their metadata representations. This design pattern ensures that the code components can be easily serialized and deserialized, maintaining data integrity and consistency.\n\nThe technical stack primarily involves Pydantic for data validation and JSON for serialization. The code also imports custom enumerations from `fenec.models.enums` to define types like `BlockType`, `ImportModuleType`, and `CommentType`, which categorize different code block elements. These enumerations provide a standardized way to classify and manage various code components, enhancing the code's modularity and extensibility.\n\nIn the context of a larger system, this code serves as a foundational layer for a code analysis or documentation tool, enabling the structured representation and storage of code components. It interacts with other components by providing a standardized way to serialize and deserialize code metadata, facilitating integration with databases like ChromaDB and potentially other systems that require detailed code metadata for analysis, search, or visualization purposes. This integration allows for advanced features such as code search, dependency analysis, and documentation generation, making it a critical component of a comprehensive code management and analysis platform.",
    "children_ids": [
        "fenec:models:models.py__*__MODULE__*__CLASS-ImportNameModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ImportModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-DependencyModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-CommentModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-DecoratorModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassKeywordModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ParameterListModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-BaseCodeBlockModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ModuleSpecificAttributes",
        "fenec:models:models.py__*__MODULE__*__CLASS-ModuleModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassSpecificAttributes",
        "fenec:models:models.py__*__MODULE__*__CLASS-ClassModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionSpecificAttributes",
        "fenec:models:models.py__*__MODULE__*__CLASS-FunctionModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-StandaloneCodeBlockSpecificAttributes",
        "fenec:models:models.py__*__MODULE__*__CLASS-StandaloneCodeBlockModel",
        "fenec:models:models.py__*__MODULE__*__CLASS-DirectoryModel"
    ]
}