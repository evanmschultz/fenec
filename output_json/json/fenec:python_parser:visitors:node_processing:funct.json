{
    "docstring": "",
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "Sequence",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "typing",
            "import_module_type": "STANDARD_LIBRARY",
            "local_module_id": ""
        },
        {
            "import_names": [
                {
                    "name": "libcst",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "",
            "import_module_type": "THIRD_PARTY",
            "local_module_id": ""
        },
        {
            "import_names": [
                {
                    "name": "FunctionModelBuilder",
                    "as_name": "",
                    "local_block_id": "fenec:python_parser:model_builders:function_model_builder.py__*__MODULE__*__CLASS-FunctionModelBuilder"
                }
            ],
            "imported_from": "fenec.python_parser.model_builders.function_model_builder",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:model_builders:function_model_builder.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "DecoratorModel",
                    "as_name": "",
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-DecoratorModel"
                },
                {
                    "name": "ParameterListModel",
                    "as_name": "",
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ParameterListModel"
                }
            ],
            "imported_from": "fenec.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "BlockType",
                    "as_name": "",
                    "local_block_id": "fenec:models:enums.py__*__MODULE__*__CLASS-BlockType"
                }
            ],
            "imported_from": "fenec.models.enums",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:enums.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "fenec.python_parser.visitors.node_processing.common_functions",
                    "as_name": "common_functions",
                    "local_block_id": ""
                }
            ],
            "imported_from": "",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:python_parser:visitors:node_processing:common_functions.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "PositionData",
                    "as_name": "",
                    "local_block_id": "fenec:utilities:processing_context.py__*__MODULE__*__CLASS-PositionData"
                }
            ],
            "imported_from": "fenec.utilities.processing_context",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:utilities:processing_context.py__*__MODULE"
        }
    ],
    "id": "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE",
    "file_path": "fenec/python_parser/visitors/node_processing/function_def_functions.py",
    "parent_id": "fenec:python_parser:visitors:node_processing__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 233,
    "code_content": "from typing import Sequence\n\nimport libcst\n\nfrom fenec.python_parser.model_builders.function_model_builder import (\n    FunctionModelBuilder,\n)\n\nfrom fenec.models.models import (\n    DecoratorModel,\n    ParameterListModel,\n    # ParameterModel,\n)\nfrom fenec.models.enums import BlockType\nimport fenec.python_parser.visitors.node_processing.common_functions as common_functions\n\nfrom fenec.utilities.processing_context import PositionData\n\n\ndef process_func_def(\n    func_id: str,\n    node: libcst.FunctionDef,\n    position_data: PositionData,\n    func_builder: FunctionModelBuilder,\n) -> None:\n    \"\"\"\n    Processes a libcst.FunctionDef node to build a function model.\n\n    Extracts various components of a function definition such as its docstring, code content, decorators, and return annotations,\n    and updates the provided FunctionModelBuilder with these details.\n\n    Args:\n        - func_id (str): The unique identifier for the function.\n        - node (libcst.FunctionDef): The function definition node from the CST.\n        - position_data (PositionData): Positional data for the function in the source code.\n        - func_builder (FunctionModelBuilder): The builder used to construct the function model.\n\n    Example:\n        ```Python\n        func_builder = FunctionModelBuilder(id=\"func1\", ...)\n        process_func_def(\"func1\", function_node, position_data, func_builder)\n        # Processes the function definition and updates the function builder.\n        ```\n    \"\"\"\n\n    docstring: str | None = node.get_docstring()\n    code_content: str = common_functions.extract_code_content(node)\n    decorators: list[DecoratorModel] | None = common_functions.extract_decorators(\n        node.decorators\n    )\n\n    returns: str = (\n        _extract_return_annotation(node.returns)\n        if node.returns\n        else \"Function has no return annotation\"\n    )\n    (\n        func_builder.set_docstring(docstring)\n        .set_code_content(code_content)\n        .set_start_line_num(position_data.start)\n        .set_end_line_num(position_data.end)\n    )\n    (\n        func_builder.set_decorators(decorators)\n        .set_is_method(_func_is_method(func_id))\n        .set_is_async(_func_is_async(node))\n        .set_return_annotation(returns)\n    )\n\n\ndef process_parameters(\n    node: libcst.Parameters,\n) -> ParameterListModel | None:\n    \"\"\"\n    Processes libcst.Parameters node to create a ParameterListModel.\n\n    Extracts parameters, keyword-only parameters, positional-only parameters, and special arguments (like *args and **kwargs)\n    from the function definition and forms a model representing these parameters.\n\n    Args:\n        - node (libcst.Parameters): The parameters node from a function definition.\n\n    Returns:\n        - ParameterListModel | None: A model representing the function's parameters, or None if there are no parameters.\n\n    Example:\n        ```Python\n        parameters_model = process_parameters(function_node.params)\n        # Processes the function parameters and returns a parameter model.\n        ```\n    \"\"\"\n\n    # params: list[ParameterModel] | None = (\n    #     _get_parameters_list(node.params) if node.params else []\n    # )\n    params: list[str] | None = (\n        _get_parameters_list(node.params) if node.params else None\n    )\n\n    # kwonly_params: list[ParameterModel] | None = (\n    #     _get_parameters_list(node.kwonly_params) if node.kwonly_params else []\n    # )\n    # posonly_params: list[ParameterModel] | None = (\n    #     _get_parameters_list(node.posonly_params) if node.posonly_params else []\n    # )\n\n    # star_arg: ParameterModel | None = (\n    #     ParameterModel(\n    #         content=common_functions.extract_stripped_code_content(node.star_arg)\n    #     )\n    #     if node.star_arg and isinstance(node.star_arg, libcst.Param)\n    #     else None\n    # )\n    # star_kwarg: ParameterModel | None = (\n    #     ParameterModel(\n    #         content=common_functions.extract_stripped_code_content(node.star_kwarg)\n    #     )\n    #     if node.star_kwarg\n    #     else None\n    # )\n    kwonly_params: list[str] | None = (\n        _get_parameters_list(node.kwonly_params) if node.kwonly_params else None\n    )\n    posonly_params: list[str] | None = (\n        _get_parameters_list(node.posonly_params) if node.posonly_params else None\n    )\n\n    star_arg: str | None = (\n        common_functions.extract_stripped_code_content(node.star_arg)\n        if node.star_arg and isinstance(node.star_arg, libcst.Param)\n        else None\n    )\n    star_kwarg: str | None = (\n        common_functions.extract_stripped_code_content(node.star_kwarg)\n        if node.star_kwarg\n        else None\n    )\n\n    if params and kwonly_params and posonly_params and star_arg and star_kwarg:\n        return ParameterListModel(\n            params=params,\n            kwonly_params=kwonly_params,\n            posonly_params=posonly_params,\n            star_arg=star_arg,\n            star_kwarg=star_kwarg,\n        )\n\n\ndef _func_is_method(id: str) -> bool:\n    \"\"\"\n    Returns true if an ancestor of the function is a class.\n\n    Args:\n        - id (str): The identifier of the function.\n\n    Returns:\n        - bool: True if the function is a method, False otherwise.\n    \"\"\"\n\n    return str(BlockType.CLASS) in id\n\n\ndef _func_is_async(node: libcst.FunctionDef) -> bool:\n    \"\"\"\n    Returns true if the function is async.\n\n    Args:\n        - node (libcst.FunctionDef): The function definition node.\n\n    Returns:\n        - bool: True if the function is async, False otherwise.\n    \"\"\"\n\n    return True if node.asynchronous else False\n\n\ndef _get_parameters_list(\n    parameter_sequence: Sequence[libcst.Param],\n    # ) -> list[ParameterModel] | None:\n) -> list[str] | None:\n    # \"\"\"\n    # Returns a list of ParameterModel representing the parameters in a function definition.\n\n    # Args:\n    #     - parameter_sequence (Sequence[libcst.Param]): The sequence of parameters from the function definition.\n\n    # Returns:\n    #     - list[ParameterModel] | None: A list of ParameterModel instances or None if there are no parameters.\n    # \"\"\"\n    \"\"\"\n    Returns a list of strings representing the parameters in a function definition.\n\n    Args:\n        - `parameter_sequence` (Sequence[libcst.Param]): The sequence of parameters from the function definition.\n\n    Returns:\n        - `list[str] | None`: A list of strings or None if there are no parameters.\n    \"\"\"\n\n    # params: list[ParameterModel] | None = None\n    params: list[str] | None = None\n\n    if parameter_sequence:\n        params = []\n        for parameter in parameter_sequence:\n            # param: ParameterModel = ParameterModel(\n            # content=common_functions.extract_stripped_code_content(parameter)\n            # )\n            param = common_functions.extract_stripped_code_content(parameter)\n            params.append(param)\n\n    return params if params else None\n\n\ndef _extract_return_annotation(\n    node_returns: libcst.Annotation | None,\n) -> str:\n    \"\"\" \"\n    Extracts the return annotation from a function definition.\n\n    Args:\n        - node_returns (libcst.Annotation | None): The return annotation node.\n\n    Returns:\n        - str: The extracted return annotation or \"No return annotation\" if none is found.\n    \"\"\"\n\n    if isinstance(node_returns, libcst.Annotation) and node_returns:\n        annotation: str | None = common_functions.extract_type_annotation(node_returns)\n        return annotation if annotation else \"No return annotation\"\n    else:\n        return \"No return annotation\"\n",
    "important_comments": [],
    "dependencies": [],
    "summary": "This Python code is a crucial component of the `fenec` project, specifically within its Python parser module, designed to process and model function definitions from a source code abstract syntax tree (AST) using the `libcst` library. Its primary purpose is to extract detailed information from function definitions, such as docstrings, code content, decorators, return annotations, and parameters, and to construct comprehensive models of these functions using the `FunctionModelBuilder`. This modeling is essential for further analysis, transformation, or documentation of Python code within the larger system.\n\nKey components of the code include the `process_func_def` function, which orchestrates the extraction of function details and updates the `FunctionModelBuilder` with these details; the `process_parameters` function, which creates a `ParameterListModel` from function parameters, including handling special arguments like `*args` and `**kwargs`; and several helper functions such as `_func_is_method`, `_func_is_async`, `_get_parameters_list`, and `_extract_return_annotation`, which perform specific tasks like determining if a function is a method or asynchronous, extracting parameter lists, and obtaining return annotations. The `FunctionModelBuilder` is used to encapsulate the function's metadata, while `DecoratorModel` and `ParameterListModel` represent decorators and parameters, respectively.\n\nThe implementation leverages the `libcst` library to traverse and manipulate the concrete syntax tree, utilizing a combination of custom utility functions from `common_functions` to extract and process code content and annotations. The code employs a structured approach to model building, using design patterns that facilitate the extraction and representation of function components in a modular and reusable manner. The use of type hints, such as `str | None` and `list[DecoratorModel] | None`, ensures type safety and clarity in the function's operations.\n\nThe technical stack includes `libcst` for parsing and manipulating Python code, which provides a robust framework for working with Python's syntax tree. The `fenec` package contributes custom modules such as `FunctionModelBuilder`, `DecoratorModel`, and `ParameterListModel`, which are integral to the function modeling process. Additionally, the code relies on utility functions from `common_functions` for extracting and processing various elements of the function definitions.\n\nIn the context of the larger `fenec` project, this code plays a critical role in the analysis and transformation of Python code. It interacts with other components by providing detailed function models that can be used for further processing, such as code refactoring, documentation generation, or integration with other analysis tools. The modular design of the code allows it to be easily extended or adapted to accommodate different types of function definitions or additional metadata extraction requirements, making it a versatile component within the `fenec` system. This functionality is crucial for systems that require detailed introspection of function signatures, such as automated documentation generators, code linters, or refactoring tools, where understanding the structure and types of function parameters is essential for accurate analysis and transformation.",
    "children_ids": [
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-process_func_def",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-process_parameters",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-_func_is_method",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-_func_is_async",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-_get_parameters_list",
        "fenec:python_parser:visitors:node_processing:function_def_functions.py__*__MODULE__*__FUNCTION-_extract_return_annotation"
    ]
}