{
    "docstring": "",
    "header": [],
    "footer": [],
    "imports": [
        {
            "import_names": [
                {
                    "name": "ArangoDBManager",
                    "as_name": "",
                    "local_block_id": "fenec:databases:arangodb:arangodb_manager.py__*__MODULE__*__CLASS-ArangoDBManager"
                }
            ],
            "imported_from": "fenec.databases.arangodb.arangodb_manager",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:databases:arangodb:arangodb_manager.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "ModuleModel",
                    "as_name": "",
                    "local_block_id": "fenec:models:models.py__*__MODULE__*__CLASS-ModuleModel"
                }
            ],
            "imported_from": "fenec.models.models",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:models:models.py__*__MODULE"
        },
        {
            "import_names": [
                {
                    "name": "ModelType",
                    "as_name": "",
                    "local_block_id": ""
                }
            ],
            "imported_from": "fenec.types.fenec",
            "import_module_type": "LOCAL",
            "local_module_id": "fenec:types:fenec.py__*__MODULE"
        }
    ],
    "id": "fenec:updaters:change_detector.py__*__MODULE",
    "file_path": "fenec/updaters/change_detector.py",
    "parent_id": "fenec:updaters__*__DIRECTORY",
    "block_type": "MODULE",
    "start_line_num": 1,
    "end_line_num": 49,
    "code_content": "from fenec.databases.arangodb.arangodb_manager import ArangoDBManager\nfrom fenec.models.models import ModuleModel\nfrom fenec.types.fenec import ModelType\n\n\nclass ChangeDetector:\n    def __init__(\n        self, all_models: tuple[ModelType, ...], arangodb_manager: ArangoDBManager\n    ) -> None:\n        self.all_models: tuple[ModelType, ...] = all_models\n        self.id_to_model: dict[str, ModelType] = {\n            model.id: model for model in all_models\n        }\n        self.arangodb_manager: ArangoDBManager = arangodb_manager\n\n    def get_affected_models(\n        self, changed_files: list[str], both_directions: bool = False\n    ) -> set[str]:\n        affected_models = set()\n\n        for model in self.all_models:\n            if isinstance(model, ModuleModel) and model.file_path in changed_files:\n                affected_models.add(model.id)\n                affected_models.update(\n                    self._get_connected_models(model.id, both_directions)\n                )\n\n        return affected_models\n\n    def _get_connected_models(self, model_id: str, both_directions: bool) -> set[str]:\n        connected_models = set()\n\n        # Get outbound models (dependencies and children)\n        outbound_models: list[ModelType] | None = (\n            self.arangodb_manager.get_outbound_models(model_id)\n        )\n        if outbound_models:\n            connected_models.update(model.id for model in outbound_models)\n\n        if both_directions:\n            # Get inbound models (dependents and parents)\n            inbound_models: list[ModelType] | None = (\n                self.arangodb_manager.get_inbound_models(model_id)\n            )\n            if inbound_models:\n                connected_models.update(model.id for model in inbound_models)\n\n        return connected_models\n",
    "important_comments": [],
    "dependencies": [],
    "summary": "The `ChangeDetector` class is a pivotal component in a system designed for tracking and analyzing changes in software models, particularly focusing on their dependencies and relationships within a graph database. Its primary purpose is to identify which models are impacted by changes in specified files, leveraging the capabilities of a graph database to explore and map model connections. This functionality is crucial for efficient dependency management and impact analysis in software development environments, particularly within CI/CD pipelines. Key components of the code include: the `ChangeDetector` class, which is initialized with a tuple of models and an `ArangoDBManager` instance, facilitating the management of model data and database interactions; the `get_affected_models` method, which determines the models affected by file changes, optionally considering bidirectional dependencies to capture a comprehensive impact scope; and the `_get_connected_models` method, which retrieves models connected to a given model ID, considering both outbound and inbound relationships based on the `both_directions` flag. This method utilizes the `ArangoDBManager` to query the graph database for model dependencies, ensuring accurate and efficient retrieval of connected models.\n\nThe implementation employs a dictionary to map model IDs to models, enabling quick access and efficient management of model collections. Set operations are used to handle collections of affected and connected models, ensuring that the operations are performed efficiently. The `ArangoDBManager` is a critical component, responsible for querying the graph database to obtain model dependencies, which is essential for the accurate functioning of the change detection mechanism. The technical stack includes the `fenec` library, which provides the `ArangoDBManager` for database interactions and `ModuleModel` for model representation. The `ModelType` from `fenec.types.fenec` is used for type annotations, ensuring type safety and clarity in the code. The use of these components indicates a reliance on the `fenec` library for managing and interacting with the graph database, which is likely a central part of the larger system's architecture.\n\nIn the context of a larger project, this code is part of a change detection mechanism within a software management or CI/CD pipeline. It interfaces with a graph database to dynamically assess the impact of code changes on interconnected modules, thereby facilitating efficient dependency management and impact analysis. This functionality is crucial for maintaining the integrity and performance of software systems, as it allows developers to understand the ripple effects of changes and make informed decisions about code modifications. The modular design of the `ChangeDetector` class allows it to be easily integrated into larger systems, providing a scalable solution for change detection and impact analysis. This integration ensures that the system can adapt to various software development environments, supporting continuous integration and delivery processes by providing real-time insights into model dependencies and their potential impacts.",
    "children_ids": [
        "fenec:updaters:change_detector.py__*__MODULE__*__CLASS-ChangeDetector"
    ]
}